<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Top Oyunu</title>
	<style>
		body{
			padding:0;
			margin:0;
			overflow: hidden;
		}
	</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script type="text/javascript">
//canvas animasyonu için gerekli kod
//canvas çizim fonksiyonu için gereken isteği 1 saniyede (1000ms'te) 60 kere gönder (60fps için)
window.animasyonFrameIstegi = (function(){

	return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( callback ){
		return window.setTimeout(callback, 1000 / 60);
		};
})();

//animasyon frame iptal
window.animasyonFrameIptal = (function(){
	return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout
})();

//canvas değişkeni

var canvas = document.getElementById("canvas"),
	ctx    = canvas.getContext("2d"),//canvas context oluşturduk
	G      = window.innerWidth,//pencere genişliğinde oyun alanı genişliği
	Y      = window.innerHeight,//pencere yüksekliğinde oyun alanı yüksekliği
	mouse = {}, //mouse objesi
	parcalar = [], //top çubuğa çarptığında çıkacak parçacıklar için array
	topum = {}, //top nesnesi
	cubuk = [2]; //iki çubuk içerecek olan array

	//canvasın tam ekran olmasını sağladık
	canvas.width  = G;
	canvas.height = Y;

	//eventlistener ekleyelim (mouseun hareketini yakalamak(takip etmek) için)
	canvas.addEventListener("mousemove", mouseHareket, true); //mousemove olduğunda(fare hareket ettiğinde) bu hareketi parametre olarak mouseHareket fonksiyonuna gönder

	//top nesnesini tanımlayalım
	topum = {
		x:50, //x ekseninde başlangıç noktasının sola olan uzaklığı (pixel)
		y:50, //y ekseninde başlangıç noktasının yukarıya olan uzaklığı (pixel)
		r:5, //radius, topa yuvarlaklık (daire şekli) vermek için
		c:"white", //color, renk için beyaz tanımladık
		xh:4, //topun x eksenindeki hızının başlangıç değeri
		yh:8, //topun y eksenindeki hızının başlangıç değeri

		ciz: function (){
			ctx.beginPath();//çizime başlayacağımızı haber vermek için
			ctx.fillStyle = this.c;//nesnenin içini doldururken verilecek stil için (biz yukarıda tanımladığımız c değişkeninden gelen rengi atadık)
			ctx.arc(this.x, this.y, this.r, 0/*başlangıç trigonometrik açısı 0*/, Math.PI*2/*bitiş trigonometrik açısı 2PI yani 360*/, false/*saat yönüne doğru*/);//oluşturulacak topun kıvrımlarını ayarlıyoruz
			ctx.fill();//çiz(doldur)
		}
	};

	//çubuk için fonksiyon oluşturalım
	function Kurek(poz) {
		this.h = 5; //sadece BU(this) fonksiyon içinde çalışacak olan küreğin yüksekliğini belirten h değişkeni
		this.w = 150; //sadece BU(this) fonksiyonu içinde çalışacak olan küreğin genişliğini belirten w değişkeni

		//küreklerin(çubukların) pozisyonunu tanımlayalım
		this.x = G/2 - this.w/2;
		this.y = (poz == "ust") ? 0 : Y - this.h;
	}

	//cubuk arrayine kürekleri(çubukları) ekleyelim
	cubuk.push(new Kurek("asagi")); //burada anlamadığım bir şey var: Kurek bir fonksiyon, neden obje gibi new keywordü ile kullandık?
	cubuk.push(new Kurek("ust"));

	//tuval çizmek için gerekli fonksiyon
	//galiba artık daha düzgün bir yapıya gitmek için attığımız ilk adım (kişisel yorum)
	function canvasCiz(){
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, G, Y);
	};

	//her şeyi canvas bölgesinde (tuvalde) çizmek için gerekli fonksiyon
	function ciz(){
		canvasCiz(); //canvası çiz
		for(var i = 0; i<cubuk.length; i++){ //çubukları(kürekleri) çiz
			p = cubuk[i];
			ctx.fillStyle = "white";
			ctx.fillRect(p.x, p.y, p.w, p.h);
		}
		topum.ciz(); //topum nesnesi içindeki çiz fonksiyonu, şu an oluşturduğumuz çiz fonksiyonu değil
		guncelle(); //çubuğun, topun yeni konumlarını 1 saniyede 60 kez değiştirecek fonksiyon
	};

	//animasyonları çalıştırmak için oluşturduğumuz döngü
	function animDongu(){
		res = animasyonFrameIstegi(animDongu);//animasyon frame isteğini resetle
		ciz(); //her şeyi çiz
	};

	animDongu();

	//ekrandaki değişiklikleri güncelle fonksiyonu gösterecek (bu fonksiyon animDongu içinde yer aldığı için saniyede 60 kere çalışır)
	function guncelle(){
		//topu hareket ettiriyoruz
		//hız: birim zamanda(bizim örneğimizde bir saniyenin altmışta biri) alınan yol !!önemli!! yani saniyenin altmışta birinde ben mouseun x eksenindeki bulunduğu noktaya hız değerim olan 4 ü eklediğimde hızı 4 olmuş olur !! , her güncelleme işleminde topun hız miktarını bulunduğu noktaya ekleyerek yol almasını sağladık
		topum.x = topum.x + topum.xh;//topun x eksenindeki bulunduğu noktaya topun x eksenindeki hızını ekle
		topum.y = topum.y + topum.yh;

		//cubugu hareket ettiriyoruz
		if(mouse.x && mouse.y){ //mouse.x VE mouse.y TRUE ise yani değer barındırıyor ise
			for(var i = 1; i < cubuk.length; i++){ //iki çubuğa da erişebilmek için for açtık
				p = cubuk[i]; //çubuğun herhangi bir PARÇASI(p)
				p.x = mouse.x - p.w/2; //eğer p.x yani çubuğun x eksenindeki başlangıcı mouse.x ile aynı olsaydı, çubuk mouseu tuttuğumuz yerden başlardı, bu yüzden mouse.xten çubuğun genişliğinin yarısını çıkardık ki çubuğun başlangıç noktası çubuğun ortasına kaysın ve mouseu tuttuğumuz yerde çubuğun ortası olsun. !!ÖNEMLİ!!
			}
		}

		//cubukları çağır
		p1 = cubuk[1]; //p1 : birinci çubuk
		p2 = cubuk[2]; //p2 : ikinci çubuk

		//çarpışma işleminin gerçekleştiği yer
		if(carpismalar(topum, cubuk[1])){//eğer topla 1. çubuk çarpıştıysa
			topum.yh = -topum.yh;//topun y eksenindeki hızının yönünü değiştir(hızı eksi ile çarp)
		}else if(carpismalar(topum, cubuk[2])){//eğer topla 2. çubuk çarpıştıysa
			topum.yh = -topum.yh;//topun y eksenindeki hızının yönünü değiştir(hızı eksi ile çarp)
		}else{//duvarlardan birine çarpmıştır (yanlara) veya çubuklara çarpmayıp yere düşmüş ya da havaya uçmuştur

			//top üst veya aşağı çubuğa çarpmazsa (phphocam çarparsa yazmış buraya...)
			if(topum.y + topum.r > Y){//top alt çubuğa çarpmadan aşağı düşerse
				topum.y =  Y - topum.r;
				oyunBitti(); //oyunu bitir
			}else if(topum.y < 0){ //top üst çubuğa çarpmadan yukarı uçarsa
				topum.y = topum.r;
				oyunBitti(); //oyunu bitir
			}

			//top sağ ve sol duvara çarparsa (çarpmazsa yazmalıydı, phphocam çarparsa yazmış)
			if(topum.x + topum.r > G){//eğer top toplam genişliği geçtiyse
				topum.xh = -topum.xh;//hızın yönünü ters çevir, yani top x ekseninde diğer tarafa doğru gitsin
				topum.x = G - topum.r;//top sağdan dışarı çıktığı için duvara yasla (topun x ekseninde bulunduğu noktayı yarıçapına eşitle)
			}else if(topum.x - topum.r < 0){//eğer genişliğin başlangıç noktasından(0) küçük olduysa yani soldan dışarı çıkarsa
				topum.xh = -topum.xh;//hızın yönünü ters çevir, yani top x ekseninde diğer tarafa doğru gitsin
				topum.x = topum.r;//top soldan dışarı çıktığı için duvara yasla (topun x ekseninde bulunduğu noktayı yarıçapına eşitle)
			}
		}//ilk if kontrolünün bitişi
	}//güncelle fonksiyonunun bitişi

	//mouseumuzu hareket ettiriyoruz.
	function mouseHareket(e){ //eventlistenerdan gelen parametreyi al, parametrede içinde, mouseun sayfanın x ekseninde ettiği hareketi(pageX) mouse.x e ata, mouseun sayfanın y ekseninde ettiği hareketi(pageY) mouse.y ye ata
		mouse.x = e.pageX; 
		mouse.y = e.pageY;
	}

	//top ile çubuk arasındaki çarpışmayı kontrol eden fonksiyon
	function carpismalar(b, p){//b: top , p: çubuk temsil eder.
		if(b.x + topum.r >= p.x && b.x - topum.r <= p.x + p.w){//eğer topun x ekseninde bulunduğu nokta(topun ortası oluyor) + topun yarıçapı >= çubuğun x ekseninde bulunduğu nokta(çubuğun sol başlangıcı oluyor) && topun orta noktası - topun yarıçapı <= çubuğun sol başlangıç noktası + çubuğun genişliği ise. !!ÖNEMLİ!! bu kontrolün amacı top çubuklara çarpıyor mu çarpmıyor mu onu öğrenmektir.
			if(b.y >= (p.y - p.h/*bana kalırsa - p.h olmamalı p.y tek başına yeterli (kişisel not)*/) && p.y > 0){//topun y ekseninde bulunduğu nokta(topun orta noktası oluyor) >= çubuğun y eksenindeki bulunduğu nokta(çubuğun üst başlangıcı oluyor) - çubuğun yüksekliği && çubuğun y ekseninde bulunduğu nokta > 0 ise. !!ÖNEMLİ!! bu kontrolün amacı topun alttaki çubuğa çarpmasını yakalamaktır
				cubukCarpisma = 1;//top 1. çubukla(alttaki çubukla) çarpıştı
				return true; //çarptığı için true döndürür
			}else if(b.y <= p.h &&  p.y == 0){//topun y ekseninde bulunduğu nokta(topun orta noktası oluyor) <= çubuğun yüksekliği && çubuğun y ekseninde bulunduğu nokta == 0 ise. !!ÖNEMLİ!! bu kontrolün amacı topun üstteki çubuğa çarpmasını yakalamaktır
				cubukCarpisma = 2;//top 2. çubukla(üstteki çubukla) çarpıştı
				return true; //çarptığı için true döndürür
			}else{//eğer buraya düştüysek, top ne üstteki çubuğa ne de alttaki çubuğa çarpmamıştır, ya aşağı düşmüş ya da yukarı uçmuştur, bu yüzden false döndürür
				return false;
			}
		}
	}//carpismalar fonksiyonu sonu

//oyunu bitiren fonksiyon
function oyunBitti(){
	ctx.fillStyle = "white";
	ctx.font = "20px Arial, sans-serif";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText("Oyun Bitti", G/2, Y/2 + 25);
	animasyonFrameIptal(res);
};

</script>
</body>
</html>